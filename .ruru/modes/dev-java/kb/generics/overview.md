+++
id = "KB-JAVA-GENERICS-V1"
title = "Java Knowledge Base: Generics Overview"
context_type = "knowledge_base"
scope = "Explanation of Java Generics including type parameters/arguments, generic classes/methods, type erasure, bounds, wildcards, raw types, inference, restrictions, and best practices."
target_audience = ["dev-java"]
granularity = "detailed_summary"
status = "active"
last_updated = "2025-04-29"
tags = ["java", "generics", "type-safety", "type-erasure", "wildcards", "bounds", "kb"]
relevance = "High: Fundamental for writing type-safe, reusable Java code."
target_mode_slug = "dev-java"
+++

# Java Generics Overview

Generics allow types to be parameters, enhancing reusability and compile-time type safety.

## Core Concepts
*   **Type Parameter:** Placeholder (e.g., `<T>`).
*   **Type Argument:** Actual type supplied (e.g., `<Integer>`).
*   **Generic Class/Interface:** Declared with type parameters (e.g., `class Box<T> { ... }`).
*   **Generic Method:** Introduces its own type parameters (e.g., `static <K, V> boolean compare(...)`).

## Type Erasure
*   Generics are mainly a compile-time feature.
*   Compiler replaces type parameters with bounds or `Object` and inserts casts.
*   Generated bytecode has no generic types, ensuring runtime compatibility and no overhead.
*   Generic type info is generally unavailable at runtime (except via reflection on signatures).

## Bounded Type Parameters
*   **Upper Bounds (`extends`):** Restricts type parameter to a type or its subtypes (e.g., `<T extends Number>`). Use `&` for multiple bounds.
*   **Lower Bounds (`super`):** Used only with wildcards.

## Wildcards (`?`)
Represent an unknown type, increasing flexibility.
*   **Upper Bounded (`? extends Type`):** Unknown subtype of `Type`. Use when *reading* (Producer). Cannot safely add elements (except `null`).
*   **Lower Bounded (`? super Type`):** Unknown supertype of `Type`. Use when *adding* `Type` or its subtypes (Consumer). Reading yields `Object`.
*   **Unbounded (`?`):** Any unknown type. Use when type doesn't matter (e.g., calling `Object` methods). Cannot safely add elements (except `null`).
*   **PECS Principle:** Producer Extends, Consumer Super.

## Raw Types
*   Using a generic type without type arguments (e.g., `Box box = new Box();`).
*   Bypasses compile-time checks, defers errors to runtime.
*   Avoid in new code; primarily for backward compatibility.

## Type Inference
*   Compiler determines type arguments based on context.
*   Allows omitting type arguments in generic method calls.
*   **Diamond Operator (`<>`):** Since Java 7, allows omitting type arguments in constructor calls (e.g., `List<String> list = new ArrayList<>();`).

## Restrictions (Due to Type Erasure)
*   Cannot use primitive types as arguments (use wrappers).
*   Cannot instantiate type parameters (`new T()`).
*   Cannot have static fields of type parameter type.
*   Cannot use `instanceof` with parameterized types (use `instanceof RawType<?>`).
*   Cannot create arrays of parameterized types (`new List<String>[10]`).
*   Cannot create generic exception classes.
*   Cannot overload methods where signatures erase to the same type.

## Best Practices
*   Use generics for type safety; avoid raw types.
*   Use bounds and wildcards (PECS) appropriately for API flexibility.
*   Prefer generic methods for local type parameters.
*   Leverage type inference (`<>`).
*   Understand type erasure limitations.

*(Source: Synthesized from `.ruru/docs/vertex/research/dev-java/explanations/20250429125420-java_generics_deep_dive.md`)*